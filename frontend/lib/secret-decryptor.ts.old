/**
 * This is a standalone module for handling secret decryption
 * with proper format handling between backend and frontend.
 * 
 * Key format differences between Node.js and WebCrypto:
 * 1. Node.js crypto (backend):
 *    - Uses separate authTag via getAuthTag()
 *    - Stores IV as hex string
 *    - Stores authTag as hex string
 *    - Stores encrypted data as base64 string
 * 
 * 2. WebCrypto API (frontend):
 *    - Requires authTag to be appended to ciphertext
 *    - Expects binary data (Uint8Array) for all inputs
 * 
 * This module handles these differences automatically.
 */

/**
 * Convert a hex string to Uint8Array
 */
function hexToUint8Array(hex: string): Uint8Array {
  try {
    // Remove any non-hex characters (like spaces or 0x prefix)
    const cleanHex = hex.replace(/[^0-9a-f]/gi, '');
    
    // Make sure we have a valid hex string (even length)
    const paddedHex = cleanHex.length % 2 === 0 ? cleanHex : '0' + cleanHex;
    
    // Convert to byte array
    const matches = paddedHex.match(/[0-9a-f]{2}/gi) || [];
    return new Uint8Array(matches.map(byte => parseInt(byte, 16)));
  } catch (error) {
    console.error("Hex conversion error:", error);
    throw new Error("Failed to convert hex to binary");
  }
}

/**
 * Convert a base64 string to Uint8Array
 */
function base64ToUint8Array(base64: string): Uint8Array {
  try {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  } catch (error) {
    console.error("Base64 decoding error:", error);
    throw new Error("Failed to decode base64 data");
  }
}

/**
 * Decrypt a secret value using the wallet-derived encryption key
 * 
 * @param encryptedValue - Base64 encoded encrypted value from backend
 * @param iv - Hex string IV from backend
 * @param authTag - Hex string authentication tag from backend
 * @returns The decrypted plaintext
 */
export async function decryptSecret(
  encryptedValue: string,
  iv: string,
  authTag: string
): Promise<string> {
  try {
    // Debug logging
    console.log("Decryption attempt with:", {
      encryptedValueLength: encryptedValue?.length, 
      ivLength: iv?.length,
      authTagLength: authTag?.length
    });
    
    // Check for encryption key in localStorage
    const encryptionKey = localStorage.getItem('solkey:encryption-key');
    if (!encryptionKey) {
      const availableKeys = Object.keys(localStorage)
        .filter(key => key.startsWith('solkey'))
        .join(', ');
      console.error("Encryption key not found in localStorage. Available keys:", availableKeys);
      throw new Error("Encryption key not available. Please authenticate with your wallet first.");
    }
    
    // Get the encryption key bytes from localStorage (base64 encoded)
    const keyBytes = base64ToUint8Array(encryptionKey);
    console.log("Encryption key bytes length:", keyBytes.length);
    
    // Validate key length
    if (keyBytes.length !== 32) {
      console.warn("Unexpected encryption key length:", keyBytes.length, "expected 32 bytes");
    }
    
    // Create a CryptoKey from the raw bytes
    const key = await crypto.subtle.importKey(
      'raw',
      keyBytes,
      { name: 'AES-GCM', length: 256 },
      false, // don't allow export
      ['decrypt']
    );
    
    // Convert hex IV to binary
    const ivBytes = hexToUint8Array(iv);
    if (ivBytes.length !== 16) {
      console.error("Invalid IV length:", ivBytes.length);
      throw new Error("Invalid IV format or length");
    }
    
    // Convert hex auth tag to binary
    const authTagBytes = hexToUint8Array(authTag);
    if (authTagBytes.length === 0) {
      throw new Error("Invalid auth tag");
    }
      // Convert base64 encrypted data to binary
    let encryptedBytes: Uint8Array;
    try {
      encryptedBytes = base64ToUint8Array(encryptedValue);
      if (encryptedBytes.length === 0) {
        throw new Error("Empty encrypted data");
      }
    } catch (e) {
      console.error("Failed to decode encrypted data:", e);
      throw new Error("Invalid encrypted data format. Expected base64-encoded data.");
    }
    
    console.log("Data prepared for decryption:", {
      ivBytesLength: ivBytes.length,
      authTagBytesLength: authTagBytes.length,
      encryptedBytesLength: encryptedBytes.length,
      // More detailed format information
      ivFormat: "hex → binary",
      authTagFormat: "hex → binary",
      encryptedFormat: "base64 → binary"
    });// Key format differences between Node.js and WebCrypto:
    // - In Node.js crypto, authTag is separated from the ciphertext
    // - In WebCrypto API, authTag should be appended to the ciphertext
    
    // For AES-GCM, WebCrypto API expects the authentication tag to be appended to the ciphertext
    // Node.js crypto returns them separately, so we need to combine them
    const combinedData = new Uint8Array(encryptedBytes.length + authTagBytes.length);
    combinedData.set(encryptedBytes);
    combinedData.set(authTagBytes, encryptedBytes.length);
    
    console.log("Data format for decryption:", {
      combinedDataLength: combinedData.length,
      encryptedBytesLength: encryptedBytes.length,
      authTagBytesLength: authTagBytes.length,
      ivBytesLength: ivBytes.length,
      // Show the first few bytes for debugging
      ivSample: Array.from(ivBytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join(''),
      encryptedSample: Array.from(encryptedBytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join(''),
      authTagSample: Array.from(authTagBytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('')
    });    // According to WebCrypto API and Node.js crypto format differences:
    // 1. Node.js returns IV, encrypted data, and authTag separately 
    // 2. WebCrypto expects authTag to be either appended or part of the ciphertext
    
    // Examine lengths for debugging
    console.log("Examining binary data lengths for format detection:", {
      ivLength: ivBytes.length,           // Should be 16 bytes
      authTagLength: authTagBytes.length, // Usually 16 bytes for AES-GCM
      encryptedLength: encryptedBytes.length
    });
    
    // Log explicit algorithm parameters
    console.log("Using AES-GCM with parameters:", {
      keyLength: 256, // bits
      tagLength: 128, // bits (16 bytes)
      ivLength: 16    // bytes
    });
    
    // Try multiple approaches - the backend implementation details make 
    // multiple approaches necessary
    console.log("Attempting decryption with different approaches...");
    
    // First, try some format checking
    if (encryptedBytes.length % 4 !== 0 || authTagBytes.length !== 16) {
      console.warn("Unusual encrypted data or tag format detected:", {
        encryptedBytesLengthMod4: encryptedBytes.length % 4,
        authTagBytesLength: authTagBytes.length
      });
    }

        // After inspecting the backend code in crypto.js, we've confirmed:
    // 1. The backend uses crypto.createCipheriv("aes-256-gcm", key, iv)
    // 2. It stores encrypted data in base64, IV and authTag in hex
    // 3. It keeps authTag separate via cipher.getAuthTag()
    
    // WebCrypto API expects authTag to be combined with ciphertext
    try {
      console.log("Attempting WebCrypto decryption with NodeJS format handling");
      
      // Backend format: separate authTag, so we combine them for WebCrypto
      // For AES-GCM in WebCrypto, the auth tag must be appended to the ciphertext
      const combinedData = new Uint8Array(encryptedBytes.length + authTagBytes.length);
      combinedData.set(encryptedBytes);
      combinedData.set(authTagBytes, encryptedBytes.length);
      
      const decrypted = await crypto.subtle.decrypt(
        {
          name: 'AES-GCM',
          iv: ivBytes,
          tagLength: 128 // 16 bytes * 8 = 128 bits
        },
        key,
        combinedData
      );
      
      // Convert decrypted ArrayBuffer to string
      const decryptedText = new TextDecoder().decode(decrypted);
      console.log("Decryption successful, text length:", decryptedText.length);
      return decryptedText;
    } catch (mainError) {
      console.warn("Main decryption approach failed:", mainError);
      
      // Fallback approach 1: Try with tag prepended
      try {
        console.log("Fallback 1: Auth tag prepended to ciphertext");
        const combinedData2 = new Uint8Array(encryptedBytes.length + authTagBytes.length);
        combinedData2.set(authTagBytes);
        combinedData2.set(encryptedBytes, authTagBytes.length);
        
        const decrypted = await crypto.subtle.decrypt(
          {
            name: 'AES-GCM',
            iv: ivBytes,
            tagLength: 128
          },
          key,
          combinedData2
        );
        
        const decryptedText = new TextDecoder().decode(decrypted);
        console.log("Decryption successful (fallback 1), text length:", decryptedText.length);
        return decryptedText;
      } catch (fallback1Error) {
        console.warn("Fallback 1 failed:", fallback1Error);
        
        // Fallback approach 2: Try only encrypted data
        try {
          console.log("Fallback 2: Using only encrypted data");
          const decrypted = await crypto.subtle.decrypt(
            {
              name: 'AES-GCM',
              iv: ivBytes,
              tagLength: 128
            },
            key,
            encryptedBytes
          );
          
          const decryptedText = new TextDecoder().decode(decrypted);
          console.log("Decryption successful (fallback 2), text length:", decryptedText.length);
          return decryptedText;
        } catch (fallback2Error) {
          console.warn("Fallback 2 failed:", fallback2Error);
          
          // Final fallback: Let's try one more approach with different tag positioning
          try {
            console.log("Final fallback: Trying with potential embedded tag");
            
            // Check if the tag is potentially embedded at the end of encrypted data
            if (encryptedBytes.length >= 16) {
              const potentialTag = encryptedBytes.slice(encryptedBytes.length - 16);
              const potentialCiphertext = encryptedBytes.slice(0, encryptedBytes.length - 16);
              
              const decrypted = await crypto.subtle.decrypt(
                {
                  name: 'AES-GCM',
                  iv: ivBytes,
                  tagLength: 128
                },
                key,
                new Uint8Array([...potentialCiphertext, ...authTagBytes])
              );
              
              const decryptedText = new TextDecoder().decode(decrypted);
              console.log("Decryption successful (final fallback), text length:", decryptedText.length);
              return decryptedText;
            }
          } catch (finalError) {
            console.error("All decryption approaches failed:", mainError);
            throw new Error("Failed to decrypt data - encryption format incompatible with WebCrypto");
          }
        }
      }
    }
          try {
            console.log("Approach 4: Last attempt with alternate tag handling");
            
            // Try with tag in a different position or format
            // Split the encrypted data in case the tag is actually embedded at a different position
            if (encryptedBytes.length >= 16) {
              console.log("Attempting to extract tag from encrypted data...");
              
              // Try extracting the tag from the end
              const potentialCiphertext = encryptedBytes.slice(0, encryptedBytes.length - 16);
              const potentialTag = encryptedBytes.slice(encryptedBytes.length - 16);
              
              const combinedData4 = new Uint8Array(potentialCiphertext.length + authTagBytes.length);
              combinedData4.set(potentialCiphertext);
              combinedData4.set(authTagBytes, potentialCiphertext.length);
              
              const decrypted = await crypto.subtle.decrypt(
                {
                  name: 'AES-GCM',
                  iv: ivBytes,
                  tagLength: 128
                },
                key,
                combinedData4
              );
              
              const decryptedText = new TextDecoder().decode(decrypted);
              console.log("Decryption successful (approach 4), text length:", decryptedText.length);
              return decryptedText;
            }
          } catch (error4) {
            console.error("All decryption approaches failed", { 
              error1, error2, error3, error4
            });
              throw new Error("Decryption failed. The data format from backend may be incompatible with WebCrypto's requirements.");
          }
          // If all approaches fail
          throw new Error("Decryption failed after trying all approaches");
        }
      }
    }
      }
    }
  } catch (error) {
    console.error('Error in decryptSecret:', error);
    throw new Error(`Failed to decrypt: ${error instanceof Error ? error.message : String(error)}`);
  }
}
